<?php
$frontEndLoggerStatus = $block->getData('frontendLogger');
if ($frontEndLoggerStatus->isEnabled()):
?>
<script data-head="true">
    let errorQueue = [];
    let sendingErrors = false;

    async function sendErrorsToAPI(force = false) {
        // If already sending errors, just under 10 errors logged and nothing in the queue, return
        if (!force && errorQueue.length < 10) {
            return;
        }

        if (sendingErrors) return;
        sendingErrors = true;

        try {
            const response = await fetch(`${window.BASE_URL}rest/V1/open_telemetry/log`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({errors: errorQueue}),
            });
            if (response.ok) {
                errorQueue = []; // Clear the error queue if the API call is successful
            } else {
                console.error("Failed to send errors to API:", response.status);
            }
        } catch (error) {
            sendingErrors = false;
            console.error("Failed to send errors to API:", error);
        } finally {
            sendingErrors = false;
        }
    }

    function addErrorToQueue(error) {
        // Check if the error is already present in the errorQueue
        const isErrorAlreadyPresent = errorQueue.some(existingError => {
            return (
                existingError.message === error.message
            );
        });

        // Push the error to the queue only if it's not already present
        if (!isErrorAlreadyPresent) {
            errorQueue.push(error);
        }

        if (!sendingErrors && !isErrorAlreadyPresent) {
            sendErrorsToAPI();
        }
    }

    function handleFilesError(event) {
        let message;
        switch (event.target.tagName) {
            case "LINK":
                message = `Could not load file: ${event.target.href}.css`;
                break;
            case "SCRIPT":
                var src = event.target.src;
                var extensionRegex = /\.([0-9a-z]+)(?=[?&]|$)/i;
                var match = src.match(extensionRegex);
                var extension = match ? match[1].toLowerCase() : '';

                if (extension && /^(jpg|jpeg|png|webp)$/.test(extension)) {
                    // If the script src ends with an image extension, don't send any message
                } else {
                    // If it's not an image extension, then send the error message
                    message = `Could not load script: ${src}`;
                }
            default:
                return; // Ignore errors for other element types
        }

        const eventError = {
            type: event.type,
            message: message,
            url: window.location.href
        };

        if (!message) return;
        addErrorToQueue(eventError);
    }

    window.addEventListener('error', (event) => {
        if (!event.error) return handleFilesError(event);
        const { message, filename, lineno, colno, error } = event;
        const setMessage = error.stack ? error.stack : `${lineno}:${colno} ${filename}`;

        const eventError = {
            type: event.type,
            message: setMessage,
            url: window.location.href,
        };
        addErrorToQueue(eventError);
    }, {
        capture: true,
        once: false,
        passive: true
    });

    // Just in case after 20 seconds force send the pending errors
    setTimeout(() => {
        sendErrorsToAPI(true);
    }, 20000);

    // Force send pending errors before leaving the page
    window.addEventListener('beforeunload', () => {
        sendErrorsToAPI(true);
    });
</script>
<?php endif; ?>
